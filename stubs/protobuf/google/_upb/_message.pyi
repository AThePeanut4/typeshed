"""Protobuf Module"""

from _typeshed import Incomplete
from typing import ClassVar, final
from typing_extensions import Self

default_pool: DescriptorPool

@final
class Arena: ...

@final
class Descriptor:
    containing_type: Incomplete
    enum_types: Incomplete
    enum_types_by_name: Incomplete
    enum_values_by_name: Incomplete
    extension_ranges: Incomplete
    extensions: Incomplete
    extensions_by_name: Incomplete
    fields: Incomplete
    fields_by_camelcase_name: Incomplete
    fields_by_name: Incomplete
    fields_by_number: Incomplete
    file: Incomplete
    full_name: Incomplete
    has_options: Incomplete
    is_extendable: Incomplete
    name: Incomplete
    nested_types: Incomplete
    nested_types_by_name: Incomplete
    oneofs: Incomplete
    oneofs_by_name: Incomplete
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def CopyToProto(self, object, /): ...
    def EnumValueName(self, *args, **kwargs): ...  # incomplete
    def GetOptions(self): ...

@final
class DescriptorPool:
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def Add(self, object, /): ...
    def AddSerializedFile(self, object, /): ...
    def FindAllExtensions(self, object, /): ...
    def FindEnumTypeByName(self, object, /): ...
    def FindExtensionByName(self, object, /): ...
    def FindExtensionByNumber(self, *args, **kwargs): ...  # incomplete
    def FindFieldByName(self, object, /): ...
    def FindFileByName(self, object, /): ...
    def FindFileContainingSymbol(self, object, /): ...
    def FindMessageTypeByName(self, object, /): ...
    def FindMethodByName(self, object, /): ...
    def FindOneofByName(self, object, /): ...
    def FindServiceByName(self, object, /): ...
    def SetFeatureSetDefaults(self, object, /): ...

@final
class EnumDescriptor:
    containing_type: Incomplete
    file: Incomplete
    full_name: Incomplete
    has_options: Incomplete
    is_closed: Incomplete
    name: Incomplete
    values: Incomplete
    values_by_name: Incomplete
    values_by_number: Incomplete
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def CopyToProto(self, object, /): ...
    def GetOptions(self): ...

@final
class EnumValueDescriptor:
    has_options: Incomplete
    index: Incomplete
    name: Incomplete
    number: Incomplete
    type: Incomplete
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def GetOptions(self): ...

@final
class ExtensionDict:
    def __contains__(self, other, /) -> bool:
        """Return bool(key in self)."""
        ...
    def __delitem__(self, other, /) -> None:
        """Delete self[key]."""
        ...
    def __eq__(self, other: object, /) -> bool:
        """Return self==value."""
        ...
    def __ge__(self, other: object, /) -> bool:
        """Return self>=value."""
        ...
    def __getitem__(self, index, /):
        """Return self[key]."""
        ...
    def __gt__(self, other: object, /) -> bool:
        """Return self>value."""
        ...
    def __iter__(self):
        """Implement iter(self)."""
        ...
    def __le__(self, other: object, /) -> bool:
        """Return self<=value."""
        ...
    def __len__(self) -> int:
        """Return len(self)."""
        ...
    def __lt__(self, other: object, /) -> bool:
        """Return self<value."""
        ...
    def __ne__(self, other: object, /) -> bool:
        """Return self!=value."""
        ...
    def __setitem__(self, index, object, /) -> None:
        """Set self[key] to value."""
        ...

@final
class ExtensionIterator:
    def __iter__(self):
        """Implement iter(self)."""
        ...
    def __next__(self):
        """Implement next(self)."""
        ...

@final
class FieldDescriptor:
    CPPTYPE_BOOL: ClassVar[int] = ...
    CPPTYPE_BYTES: ClassVar[int] = ...
    CPPTYPE_DOUBLE: ClassVar[int] = ...
    CPPTYPE_ENUM: ClassVar[int] = ...
    CPPTYPE_FLOAT: ClassVar[int] = ...
    CPPTYPE_INT32: ClassVar[int] = ...
    CPPTYPE_INT64: ClassVar[int] = ...
    CPPTYPE_MESSAGE: ClassVar[int] = ...
    CPPTYPE_STRING: ClassVar[int] = ...
    CPPTYPE_UINT32: ClassVar[int] = ...
    CPPTYPE_UINT64: ClassVar[int] = ...
    LABEL_OPTIONAL: ClassVar[int] = ...
    LABEL_REPEATED: ClassVar[int] = ...
    LABEL_REQUIRED: ClassVar[int] = ...
    TYPE_BOOL: ClassVar[int] = ...
    TYPE_BYTES: ClassVar[int] = ...
    TYPE_DOUBLE: ClassVar[int] = ...
    TYPE_ENUM: ClassVar[int] = ...
    TYPE_FIXED32: ClassVar[int] = ...
    TYPE_FIXED64: ClassVar[int] = ...
    TYPE_FLOAT: ClassVar[int] = ...
    TYPE_GROUP: ClassVar[int] = ...
    TYPE_INT32: ClassVar[int] = ...
    TYPE_INT64: ClassVar[int] = ...
    TYPE_MESSAGE: ClassVar[int] = ...
    TYPE_SFIXED32: ClassVar[int] = ...
    TYPE_SFIXED64: ClassVar[int] = ...
    TYPE_SINT32: ClassVar[int] = ...
    TYPE_SINT64: ClassVar[int] = ...
    TYPE_STRING: ClassVar[int] = ...
    TYPE_UINT32: ClassVar[int] = ...
    TYPE_UINT64: ClassVar[int] = ...
    camelcase_name: Incomplete
    containing_oneof: Incomplete
    containing_type: Incomplete
    cpp_type: Incomplete
    default_value: Incomplete
    enum_type: Incomplete
    extension_scope: Incomplete
    file: Incomplete
    full_name: Incomplete
    has_default_value: Incomplete
    has_options: Incomplete
    has_presence: Incomplete
    index: Incomplete
    is_extension: Incomplete
    is_packed: Incomplete
    json_name: Incomplete
    label: Incomplete
    message_type: Incomplete
    name: Incomplete
    number: Incomplete
    type: Incomplete
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def GetOptions(self): ...

@final
class FileDescriptor:
    dependencies: Incomplete
    enum_types_by_name: Incomplete
    extensions_by_name: Incomplete
    has_options: Incomplete
    message_types_by_name: Incomplete
    name: Incomplete
    package: Incomplete
    pool: Incomplete
    public_dependencies: Incomplete
    serialized_pb: Incomplete
    services_by_name: Incomplete
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def CopyToProto(self, object, /): ...
    def GetOptions(self): ...

@final
class MapIterator:
    def __iter__(self):
        """Implement iter(self)."""
        ...
    def __next__(self):
        """Implement next(self)."""
        ...

@final
class Message:
    """A ProtocolMessage"""
    Extensions: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...  # incomplete
    def ByteSize(self): ...
    def Clear(self): ...
    def ClearExtension(self, object, /): ...
    def ClearField(self, object, /): ...
    def CopyFrom(self, object, /): ...
    def DiscardUnknownFields(self): ...
    def FindInitializationErrors(self): ...
    @classmethod
    def FromString(cls, object, /):
        """Creates new method instance from given serialized data."""
        ...
    def HasExtension(self, object, /):
        """Checks if a message field is set."""
        ...
    def HasField(self, object, /):
        """Checks if a message field is set."""
        ...
    def IsInitialized(self, *args, **kwargs):
        """Checks if all required fields of a protocol message are set."""
        ...
    def ListFields(self):
        """Lists all set fields of a message."""
        ...
    def MergeFrom(self, object, /):
        """Merges a protocol message into the current message."""
        ...
    def MergeFromString(self, object, /):
        """Merges a serialized message into the current message."""
        ...
    def ParseFromString(self, object, /):
        """Parses a serialized message into the current message."""
        ...
    def SerializePartialToString(self, *args, **kwargs):
        """Serializes the message to a string, even if it isn't initialized."""
        ...
    def SerializeToString(self, *args, **kwargs):
        """Serializes the message to a string, only for initialized messages."""
        ...
    def SetInParent(self):
        """Sets the has bit of the given field in its parent message."""
        ...
    def UnknownFields(self):
        """Parse unknown field set"""
        ...
    def WhichOneof(self, object, /):
        """Returns the name of the field set inside a oneof, or None if no field is set."""
        ...
    def __contains__(self, other, /) -> bool:
        """Checks if a message field is set."""
        ...
    def __deepcopy__(self, memo=None):
        """Makes a deep copy of the class."""
        ...
    def __delattr__(self, name, /):
        """Implement delattr(self, name)."""
        ...
    def __eq__(self, other: object, /) -> bool:
        """Return self==value."""
        ...
    def __ge__(self, other: object, /) -> bool:
        """Return self>=value."""
        ...
    def __gt__(self, other: object, /) -> bool:
        """Return self>value."""
        ...
    def __le__(self, other: object, /) -> bool:
        """Return self<=value."""
        ...
    def __lt__(self, other: object, /) -> bool:
        """Return self<value."""
        ...
    def __ne__(self, other: object, /) -> bool:
        """Return self!=value."""
        ...
    def __setattr__(self, name, value, /):
        """Implement setattr(self, name, value)."""
        ...

@final
class MessageMeta(type): ...

@final
class MethodDescriptor:
    client_streaming: Incomplete
    containing_service: Incomplete
    full_name: Incomplete
    index: Incomplete
    input_type: Incomplete
    name: Incomplete
    output_type: Incomplete
    server_streaming: Incomplete
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def CopyToProto(self, object, /): ...
    def GetOptions(self): ...

@final
class OneofDescriptor:
    containing_type: Incomplete
    fields: Incomplete
    full_name: Incomplete
    has_options: Incomplete
    index: Incomplete
    name: Incomplete
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def GetOptions(self): ...

@final
class RepeatedCompositeContainer:
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def MergeFrom(self, object, /): ...
    def add(self, *args, **kwargs): ...  # incomplete
    def append(self, object, /): ...
    def extend(self, object, /): ...
    def insert(self, *args, **kwargs): ...  # incomplete
    def pop(self, *args, **kwargs): ...  # incomplete
    def remove(self, object, /): ...
    def reverse(self): ...
    def sort(self, *args, **kwargs): ...  # incomplete
    def __deepcopy__(self, memo=None): ...
    def __delitem__(self, other, /) -> None: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __ge__(self, other: object, /) -> bool: ...
    def __getitem__(self, index, /): ...
    def __gt__(self, other: object, /) -> bool: ...
    def __le__(self, other: object, /) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object, /) -> bool: ...
    def __ne__(self, other: object, /) -> bool: ...
    def __setitem__(self, index, object, /) -> None: ...

@final
class RepeatedScalarContainer:
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def MergeFrom(self, object, /): ...
    def append(self, object, /): ...
    def extend(self, object, /): ...
    def insert(self, *args, **kwargs): ...  # incomplete
    def pop(self, *args, **kwargs): ...  # incomplete
    def remove(self, object, /): ...
    def reverse(self): ...
    def sort(self, *args, **kwargs): ...  # incomplete
    def __deepcopy__(self, memo=None): ...
    def __delitem__(self, other, /) -> None: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __ge__(self, other: object, /) -> bool: ...
    def __getitem__(self, index, /): ...
    def __gt__(self, other: object, /) -> bool: ...
    def __le__(self, other: object, /) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object, /) -> bool: ...
    def __ne__(self, other: object, /) -> bool: ...
    def __reduce__(self): ...
    def __setitem__(self, index, object, /) -> None: ...

@final
class ServiceDescriptor:
    file: Incomplete
    full_name: Incomplete
    index: Incomplete
    methods: Incomplete
    methods_by_name: Incomplete
    name: Incomplete
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def CopyToProto(self, object, /): ...
    def FindMethodByName(self, object, /): ...
    def GetOptions(self): ...

@final
class UnknownFieldSet:
    def __new__(cls, *args, **kwargs) -> Self: ...  # incomplete
    def __getitem__(self, index, /): ...
    def __len__(self) -> int: ...

def SetAllowOversizeProtos(object, /):
    """Enable/disable oversize proto parsing."""
    ...
