"""Contains an abstract base class for protocol messages."""

from collections.abc import Sequence
from typing import Any
from typing_extensions import Self

from .descriptor import Descriptor, FieldDescriptor
from .internal.extension_dict import _ExtensionDict, _ExtensionFieldDescriptor

class Error(Exception):
    """Base error type for this module."""
    ...
class DecodeError(Error):
    """Exception raised when deserializing messages."""
    ...
class EncodeError(Error):
    """Exception raised when serializing messages."""
    ...

class Message:
    """
    Abstract base class for protocol messages.

    Protocol message classes are almost always generated by the protocol
    compiler.  These generated types subclass Message and implement the methods
    shown below.
    """
    DESCRIPTOR: Descriptor
    def __deepcopy__(self, memo: Any = None) -> Self: ...
    def __eq__(self, other_msg):
        """Recursively compares two messages by value and structure."""
        ...
    def __ne__(self, other_msg): ...
    def MergeFrom(self, other_msg: Self) -> None: ...
    def CopyFrom(self, other_msg: Self) -> None: ...
    def Clear(self) -> None: ...
    def SetInParent(self) -> None: ...
    def IsInitialized(self) -> bool: ...
    def MergeFromString(self, serialized: bytes) -> int: ...
    def ParseFromString(self, serialized: bytes) -> int: ...
    def SerializeToString(self, *, deterministic: bool = ...) -> bytes: ...
    def SerializePartialToString(self, *, deterministic: bool = ...) -> bytes: ...
    def ListFields(self) -> Sequence[tuple[FieldDescriptor, Any]]: ...
    def HasExtension(self, field_descriptor: _ExtensionFieldDescriptor[Self, Any]) -> bool: ...
    def ClearExtension(self, field_descriptor: _ExtensionFieldDescriptor[Self, Any]) -> None: ...
    # The TypeVar must be bound to `Message` or we get mypy errors, so we cannot use `Self` for `Extensions`
    @property
    def Extensions(self) -> _ExtensionDict[Self]: ...
    def ByteSize(self) -> int: ...
    @classmethod
    def FromString(cls, s: bytes) -> Self: ...
    # Intentionally left out typing on these three methods, because they are
    # stringly typed and it is not useful to call them on a Message directly.
    # We prefer more specific typing on individual subclasses of Message
    # See https://github.com/dropbox/mypy-protobuf/issues/62 for details
    def HasField(self, field_name: Any) -> bool:
        """
        Checks if a certain field is set for the message.

        For a oneof group, checks if any field inside is set. Note that if the
        field_name is not defined in the message descriptor, :exc:`ValueError` will
        be raised.

        Args:
          field_name (str): The name of the field to check for presence.

        Returns:
          bool: Whether a value has been set for the named field.

        Raises:
          ValueError: if the `field_name` is not a member of this message.
        """
        ...
    def ClearField(self, field_name: Any) -> None:
        """
        Clears the contents of a given field.

        Inside a oneof group, clears the field set. If the name neither refers to a
        defined field or oneof group, :exc:`ValueError` is raised.

        Args:
          field_name (str): The name of the field to check for presence.

        Raises:
          ValueError: if the `field_name` is not a member of this message.
        """
        ...
    def WhichOneof(self, oneof_group: Any) -> Any:
        """
        Returns the name of the field that is set inside a oneof group.

        If no field is set, returns None.

        Args:
          oneof_group (str): the name of the oneof group to check.

        Returns:
          str or None: The name of the group that is set, or None.

        Raises:
          ValueError: no group with the given name exists
        """
        ...
    # TODO: check kwargs
    def __init__(self, *args, **kwargs) -> None: ...
