import sys
from types import TracebackType
from typing import ClassVar
from typing_extensions import Self

from ._distutils.errors import DistutilsError

__all__ = ["AbstractSandbox", "DirectorySandbox", "SandboxViolation", "run_setup"]

class UnpickleableException(Exception):
    """An exception representing another Exception that could not be pickled."""
    @staticmethod
    def dump(type, exc):
        """
        Always return a dumped (pickled) type and exc. If exc can't be pickled,
        wrap it in UnpickleableException first.
        """
        ...

class ExceptionSaver:
    """
    A Context Manager that will save an exception, serialize, and restore it
    later.
    """
    def __enter__(self) -> Self: ...
    def __exit__(self, type: type[BaseException] | None, exc: BaseException | None, tb: TracebackType | None) -> bool: ...
    def resume(self) -> None:
        """restore and re-raise any exception"""
        ...

def run_setup(setup_script, args):
    """Run a distutils setup script, sandboxed in its directory"""
    ...

class AbstractSandbox:
    """Wrap 'os' module and 'open()' builtin for virtualizing setup scripts"""
    def __enter__(self) -> None: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None
    ) -> None: ...
    def run(self, func):
        """Run 'func' under os sandboxing"""
        ...
    # Dynamically created
    if sys.platform == "win32":
        def startfile(self, path, *args, **kw): ...
    else:
        def chown(self, path, *args, **kw): ...
        def chroot(self, path, *args, **kw): ...
        def lchown(self, path, *args, **kw): ...
        def mkfifo(self, path, *args, **kw): ...
        def mknod(self, path, *args, **kw): ...
        def pathconf(self, path, *args, **kw): ...

    def access(self, path, *args, **kw): ...
    def chdir(self, path, *args, **kw): ...
    def chmod(self, path, *args, **kw): ...
    def getcwd(self, *args, **kw): ...
    def link(self, src, dst, *args, **kw): ...
    def listdir(self, path, *args, **kw): ...
    def lstat(self, path, *args, **kw): ...
    def mkdir(self, path, *args, **kw): ...
    def open(self, path, *args, **kw): ...
    def readlink(self, path, *args, **kw): ...
    def remove(self, path, *args, **kw): ...
    def rename(self, src, dst, *args, **kw): ...
    def rmdir(self, path, *args, **kw): ...
    def stat(self, path, *args, **kw): ...
    def symlink(self, src, dst, *args, **kw): ...
    def unlink(self, path, *args, **kw): ...
    def utime(self, path, *args, **kw): ...

class DirectorySandbox(AbstractSandbox):
    """Restrict operations to a single subdirectory - pseudo-chroot"""
    write_ops: ClassVar[dict[str, None]]
    def __init__(self, sandbox, exceptions=...) -> None: ...
    def tmpnam(self) -> None: ...
    def open(self, file, flags, mode: int = 511, *args, **kw):
        """Called for low-level os.open()"""
        ...

class SandboxViolation(DistutilsError):
    """A setup script attempted to modify the filesystem outside the sandbox"""
    tmpl: str
