from _typeshed import Incomplete
from typing import Final
from typing_extensions import TypeAlias

import _win32typing
from win32com.client import dynamic

_Stringifiable: TypeAlias = object

def GetObject(Pathname: str | None = ..., Class: Incomplete | None = ..., clsctx: Incomplete | None = ...) -> CDispatch:
    r"""
    Mimic VB's GetObject() function.

    ob = GetObject(Class = "ProgID") or GetObject(Class = clsid) will
    connect to an already running instance of the COM object.

    ob = GetObject(r"c:\blah\blah\foo.xls") (aka the COM moniker syntax)
    will return a ready to use Python wrapping of the required COM object.

    Note: You must specifiy one or the other of these arguments. I know
    this isn't pretty, but it is what VB does. Blech. If you don't
    I'll throw ValueError at you. :)

    This will most likely throw pythoncom.com_error if anything fails.
    """
    ...
def GetActiveObject(Class, clsctx=...):
    """Python friendly version of GetObject's ProgID/CLSID functionality."""
    ...
def Moniker(Pathname, clsctx=...):
    """Python friendly version of GetObject's moniker functionality."""
    ...
def Dispatch(
    dispatch: str | dynamic.PyIDispatchType | dynamic._GoodDispatchTypes | dynamic.PyIUnknownType,
    userName: str | None = ...,
    resultCLSID: _Stringifiable | None = ...,
    typeinfo: _win32typing.PyITypeInfo | None = ...,
    clsctx: int = ...,
) -> dynamic.CDispatch:
    """Creates a Dispatch based COM object."""
    ...
def DispatchEx(
    clsid,
    machine: Incomplete | None = ...,
    userName: Incomplete | None = ...,
    resultCLSID: Incomplete | None = ...,
    typeinfo: Incomplete | None = ...,
    clsctx: Incomplete | None = ...,
):
    """Creates a Dispatch based COM object on a specific machine."""
    ...

class CDispatch(dynamic.CDispatch):
    """
    The dynamic class used as a last resort.
    The purpose of this overriding of dynamic.CDispatch is to perpetuate the policy
    of using the makepy generated wrapper Python class instead of dynamic.CDispatch
    if/when possible.
    """
    def __dir__(self): ...

def CastTo(ob, target, typelib: Incomplete | None = ...):
    """'Cast' a COM object to another interface"""
    ...

class Constants:
    """A container for generated COM constants."""
    __dicts__: Incomplete
    def __getattr__(self, a: str): ...

constants: Final[Constants]

class EventsProxy:
    def __init__(self, ob) -> None: ...
    def __del__(self) -> None: ...
    def __getattr__(self, attr: str): ...
    def __setattr__(self, attr: str, val) -> None: ...

def DispatchWithEvents(clsid, user_event_class):
    """
    Create a COM object that can fire events to a user defined class.
    clsid -- The ProgID or CLSID of the object to create.
    user_event_class -- A Python class object that responds to the events.

    This requires makepy support for the COM object being created.  If
    this support does not exist it will be automatically generated by
    this function.  If the object does not support makepy, a TypeError
    exception will be raised.

    The result is a class instance that both represents the COM object
    and handles events from the COM object.

    It is important to note that the returned instance is not a direct
    instance of the user_event_class, but an instance of a temporary
    class object that derives from three classes:
    * The makepy generated class for the COM object
    * The makepy generated class for the COM events
    * The user_event_class as passed to this function.

    If this is not suitable, see the getevents function for an alternative
    technique of handling events.

    Object Lifetimes:  Whenever the object returned from this function is
    cleaned-up by Python, the events will be disconnected from
    the COM object.  This is almost always what should happen,
    but see the documentation for getevents() for more details.

    Example:

    >>> class IEEvents:
    ...    def OnVisible(self, visible):
    ...       print("Visible changed:", visible)
    ...
    >>> ie = DispatchWithEvents("InternetExplorer.Application", IEEvents)
    >>> ie.Visible = 1
    Visible changed: 1
    >>>
    """
    ...
def WithEvents(disp, user_event_class):
    """
    Similar to DispatchWithEvents - except that the returned
    object is *not* also usable as the original Dispatch object - that is
    the returned object is not dispatchable.

    The difference is best summarised by example.

    >>> class IEEvents:
    ...    def OnVisible(self, visible):
    ...       print("Visible changed:", visible)
    ...
    >>> ie = Dispatch("InternetExplorer.Application")
    >>> ie_events = WithEvents(ie, IEEvents)
    >>> ie.Visible = 1
    Visible changed: 1

    Compare with the code sample for DispatchWithEvents, where you get a
    single object that is both the interface and the event handler.  Note that
    the event handler instance will *not* be able to use 'self.' to refer to
    IE's methods and properties.

    This is mainly useful where using DispatchWithEvents causes
    circular reference problems that the simple proxy doesn't deal with
    """
    ...
def getevents(clsid):
    """
    Determine the default outgoing interface for a class, given
    either a clsid or progid. It returns a class - you can
    conveniently derive your own handler from this class and implement
    the appropriate methods.

    This method relies on the classes produced by makepy. You must use
    either makepy or the gencache module to ensure that the
    appropriate support classes have been generated for the com server
    that you will be handling events from.

    Beware of COM circular references.  When the Events class is connected
    to the COM object, the COM object itself keeps a reference to the Python
    events class.  Thus, neither the Events instance or the COM object will
    ever die by themselves.  The 'close' method on the events instance
    must be called to break this chain and allow standard Python collection
    rules to manage object lifetimes.  Note that DispatchWithEvents() does
    work around this problem by the use of a proxy object, but if you use
    the getevents() function yourself, you must make your own arrangements
    to manage this circular reference issue.

    Beware of creating Python circular references: this will happen if your
    handler has a reference to an object that has a reference back to
    the event source. Call the 'close' method to break the chain.

    Example:

    >>>win32com.client.gencache.EnsureModule('{EAB22AC0-30C1-11CF-A7EB-0000C05BAE0B}',0,1,1)
    <module 'win32com.gen_py.....
    >>>
    >>> class InternetExplorerEvents(win32com.client.getevents("InternetExplorer.Application.1")):
    ...    def OnVisible(self, Visible):
    ...        print("Visibility changed: ", Visible)
    ...
    >>>
    >>> ie=win32com.client.Dispatch("InternetExplorer.Application.1")
    >>> events=InternetExplorerEvents(ie)
    >>> ie.Visible=1
    Visibility changed:  1
    >>>
    """
    ...
def Record(name, object):
    """
    Creates a new record object, given the name of the record,
    and an object from the same type library.

    Example usage would be:
      app = win32com.client.Dispatch("Some.Application")
      point = win32com.client.Record("SomeAppPoint", app)
      point.x = 0
      point.y = 0
      app.MoveTo(point)
    """
    ...

class DispatchBaseClass:
    def __init__(self, oobj: Incomplete | None = ...) -> None: ...
    def __dir__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __getattr__(self, attr: str): ...
    def __setattr__(self, attr: str, value) -> None: ...

class CoClassBaseClass:
    def __init__(self, oobj: Incomplete | None = ...) -> None: ...
    def __getattr__(self, attr: str): ...
    def __setattr__(self, attr: str, value) -> None: ...
    def __maybe__call__(self, *args, **kwargs): ...
    def __maybe__str__(self, *args): ...
    def __maybe__int__(self, *args): ...
    def __maybe__iter__(self): ...
    def __maybe__len__(self): ...
    def __maybe__bool__(self): ...

class VARIANT:
    varianttype: Incomplete
    def __init__(self, vt, value) -> None: ...
    value: Incomplete
