"""
an adaptation of the MySQL C API (mostly)

You probably are better off using MySQLdb instead of using this
module directly.

In general, renaming goes from mysql_* to _mysql.*. _mysql.connect()
returns a connection object (MYSQL). Functions which expect MYSQL * as
an argument are now methods of the connection object. A number of things
return result objects (MYSQL_RES). Functions which expect MYSQL_RES * as
an argument are now methods of the result object. Deprecated functions
(as of 3.23) are NOT implemented.
"""

import builtins
from _typeshed import Incomplete

import MySQLdb._exceptions

version_info: tuple[Incomplete, ...]

class DataError(MySQLdb._exceptions.DatabaseError):
    """
    Exception raised for errors that are due to problems with the
    processed data like division by zero, numeric value out of range,
    etc.
    """
    ...
class DatabaseError(MySQLdb._exceptions.Error):
    """
    Exception raised for errors that are related to the
    database.
    """
    ...
class Error(MySQLdb._exceptions.MySQLError):
    """
    Exception that is the base class of all other error exceptions
    (not Warning).
    """
    ...
class IntegrityError(MySQLdb._exceptions.DatabaseError):
    """
    Exception raised when the relational integrity of the database
    is affected, e.g. a foreign key check fails, duplicate key,
    etc.
    """
    ...
class InterfaceError(MySQLdb._exceptions.Error):
    """
    Exception raised for errors that are related to the database
    interface rather than the database itself.
    """
    ...
class InternalError(MySQLdb._exceptions.DatabaseError):
    """
    Exception raised when the database encounters an internal
    error, e.g. the cursor is not valid anymore, the transaction is
    out of sync, etc.
    """
    ...
class MySQLError(Exception):
    """Exception related to operation with MySQL."""
    ...
class NotSupportedError(MySQLdb._exceptions.DatabaseError):
    """
    Exception raised in case a method or database API was used
    which is not supported by the database, e.g. requesting a
    .rollback() on a connection that does not support transaction or
    has transactions turned off.
    """
    ...
class OperationalError(MySQLdb._exceptions.DatabaseError):
    """
    Exception raised for errors that are related to the database's
    operation and not necessarily under the control of the programmer,
    e.g. an unexpected disconnect occurs, the data source name is not
    found, a transaction could not be processed, a memory allocation
    error occurred during processing, etc.
    """
    ...
class ProgrammingError(MySQLdb._exceptions.DatabaseError):
    """
    Exception raised for programming errors, e.g. table not found
    or already exists, syntax error in the SQL statement, wrong number
    of parameters specified, etc.
    """
    ...
class Warning(builtins.Warning, MySQLdb._exceptions.MySQLError):
    """
    Exception raised for important warnings like data truncations
    while inserting, etc.
    """
    ...

class connection:
    """
    Returns a MYSQL connection object. Exclusive use of
    keyword parameters strongly recommended. Consult the
    MySQL C API documentation for more details.

    host
      string, host to connect

    user
      string, user to connect as

    password
      string, password to use

    database
      string, database to use

    port
      integer, TCP/IP port to connect to

    unix_socket
      string, location of unix_socket (UNIX-ish only)

    conv
      mapping, maps MySQL FIELD_TYPE.* to Python functions which
      convert a string to the appropriate Python type

    connect_timeout
      number of seconds to wait before the connection
      attempt fails.

    compress
      if set, gzip compression is enabled

    named_pipe
      if set, connect to server via named pipe (Windows only)

    init_command
      command which is run once the connection is created

    read_default_file
      see the MySQL documentation for mysql_options()

    read_default_group
      see the MySQL documentation for mysql_options()

    client_flag
      client flags from MySQLdb.constants.CLIENT

    load_infile
      int, non-zero enables LOAD LOCAL INFILE, zero disables
    """
    client_flag: Incomplete
    converter: Incomplete
    open: Incomplete
    port: Incomplete
    server_capabilities: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def _get_native_connection(self): ...
    def affected_rows(self): ...
    def autocommit(self, on): ...
    def change_user(self, *args, **kwargs): ...
    def character_set_name(self): ...
    def close(self): ...
    def commit(self): ...
    def dump_debug_info(self): ...
    def errno(self): ...
    def error(self): ...
    def escape(self, obj, dict): ...
    def escape_string(self, s): ...
    def field_count(self): ...
    def fileno(self): ...
    def get_autocommit(self): ...
    def get_character_set_info(self): ...
    def get_host_info(self): ...
    def get_proto_info(self): ...
    def get_server_info(self): ...
    def info(self): ...
    def insert_id(self): ...
    def kill(self, *args, **kwargs): ...
    def next_result(self): ...
    def ping(self): ...
    def query(self, query): ...
    def read_query_result(self): ...
    def rollback(self): ...
    def select_db(self, *args, **kwargs): ...
    def send_query(self, *args, **kwargs): ...
    def set_character_set(self, charset: str) -> None: ...
    def set_server_option(self, option): ...
    def shutdown(self): ...
    def sqlstate(self): ...
    def stat(self): ...
    def store_result(self): ...
    def string_literal(self, obj, /) -> str: ...
    def thread_id(self): ...
    def use_result(self): ...
    def discard_result(self) -> None: ...
    def warning_count(self): ...
    def __delattr__(self, name: str, /) -> None: ...
    def __setattr__(self, name: str, value, /) -> None: ...

class result:
    """
    result(connection, use=0, converter={}) -- Result set from a query.

    Creating instances of this class directly is an excellent way to
    shoot yourself in the foot. If using _mysql.connection directly,
    use connection.store_result() or connection.use_result() instead.
    If using MySQLdb.Connection, this is done by the cursor class.
    Just forget you ever saw this. Forget... FOR-GET...
    """
    converter: Incomplete
    has_next: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def data_seek(self, n): ...
    def describe(self): ...
    def fetch_row(self, *args, **kwargs): ...
    def discard(self) -> None: ...
    def field_flags(self): ...
    def num_fields(self): ...
    def num_rows(self): ...
    def __delattr__(self, name: str, /) -> None: ...
    def __setattr__(self, name: str, value, /) -> None: ...

def connect(*args, **kwargs): ...
def debug(*args, **kwargs): ...
def escape(obj, dict): ...
def escape_string(s): ...
def get_client_info(): ...
def string_literal(obj, /) -> str: ...
