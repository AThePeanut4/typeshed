from collections.abc import Collection, Container, Generator, Iterable, Iterator, MutableSet
from itertools import islice
from typing import Any, Literal, Protocol, SupportsIndex, TypeVar, overload
from typing_extensions import Self

_T_co = TypeVar("_T_co", covariant=True)

class _RSub(Iterable[_T_co], Protocol):
    def __new__(cls: type[_RSub[_T_co]], param: list[_T_co], /) -> _RSub[_T_co]: ...

class IndexedSet(MutableSet[Any]):
    """
    ``IndexedSet`` is a :class:`collections.MutableSet` that maintains
    insertion order and uniqueness of inserted elements. It's a hybrid
    type, mostly like an OrderedSet, but also :class:`list`-like, in
    that it supports indexing and slicing.

    Args:
        other (iterable): An optional iterable used to initialize the set.

    >>> x = IndexedSet(list(range(4)) + list(range(8)))
    >>> x
    IndexedSet([0, 1, 2, 3, 4, 5, 6, 7])
    >>> x - set(range(2))
    IndexedSet([2, 3, 4, 5, 6, 7])
    >>> x[-1]
    7
    >>> fcr = IndexedSet('freecreditreport.com')
    >>> ''.join(fcr[:fcr.index('.')])
    'frecditpo'

    Standard set operators and interoperation with :class:`set` are
    all supported:

    >>> fcr & set('cash4gold.com')
    IndexedSet(['c', 'd', 'o', '.', 'm'])

    As you can see, the ``IndexedSet`` is almost like a ``UniqueList``,
    retaining only one copy of a given value, in the order it was
    first added. For the curious, the reason why IndexedSet does not
    support setting items based on index (i.e, ``__setitem__()``),
    consider the following dilemma::

      my_indexed_set = [A, B, C, D]
      my_indexed_set[2] = A

    At this point, a set requires only one *A*, but a :class:`list` would
    overwrite *C*. Overwriting *C* would change the length of the list,
    meaning that ``my_indexed_set[2]`` would not be *A*, as expected with a
    list, but rather *D*. So, no ``__setitem__()``.

    Otherwise, the API strives to be as complete a union of the
    :class:`list` and :class:`set` APIs as possible.
    """
    item_index_map: dict[Any, Any]
    item_list: list[Any]
    dead_indices: list[int]
    def __init__(self, other: Iterable[Any] | None = None) -> None: ...
    def __len__(self) -> int: ...
    def __contains__(self, item: Any) -> bool: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __reversed__(self) -> Generator[Any, None, None]: ...
    @classmethod
    def from_iterable(cls, it: Iterable[Any]) -> Self: ...
    def add(self, item: Any) -> None: ...
    def remove(self, item: Any) -> None: ...
    def discard(self, item: Any) -> None: ...
    def clear(self) -> None: ...
    def isdisjoint(self, other: Iterable[Any]) -> bool: ...
    def issubset(self, other: Collection[Any]) -> bool: ...
    def issuperset(self, other: Collection[Any]) -> bool: ...
    def union(self, *others: Iterable[Any]) -> Self: ...
    def iter_intersection(self, *others: Container[Any]) -> Generator[Any, None, None]: ...
    def intersection(self, *others: Container[Any]) -> Self: ...
    def iter_difference(self, *others: Iterable[Any]) -> Generator[Any, None, None]: ...
    def difference(self, *others: Iterable[Any]) -> Self: ...
    def symmetric_difference(self, *others: Container[Any]) -> Self: ...
    # __or__ = union
    __ror__ = union
    # __and__ = intersection
    __rand__ = intersection
    # __sub__ = difference
    # __xor__ = symmetric_difference
    __rxor__ = symmetric_difference
    def __rsub__(self, other: _RSub[_T_co]) -> _RSub[_T_co]: ...
    def update(self, *others: Iterable[Any]) -> None: ...
    def intersection_update(self, *others: Iterable[Any]) -> None: ...
    def difference_update(self, *others: Container[Any]) -> None: ...
    def symmetric_difference_update(self, other: Iterable[Any]) -> None: ...
    def iter_slice(self, start: int, stop: int, step: int | None = None) -> islice[Iterable[Any]]: ...
    @overload
    def __getitem__(self, index: slice) -> Self: ...
    @overload
    def __getitem__(self, index: SupportsIndex) -> Any: ...
    def pop(self, index: int | None = None) -> Any: ...
    def count(self, val: Any) -> Literal[0, 1]: ...
    def reverse(self) -> None: ...
    def sort(self, **kwargs) -> None: ...
    def index(self, val: Any) -> int: ...

def complement(wrapped: Iterable[Any]) -> _ComplementSet: ...

class _ComplementSet:
    def __init__(
        self, included: set[Any] | frozenset[Any] | None = None, excluded: set[Any] | frozenset[Any] | None = None
    ) -> None: ...
    def complemented(self) -> _ComplementSet: ...
    __invert__ = complemented
    def complement(self) -> None:
        """convert the current set to its complement in-place"""
        ...
    def __contains__(self, item: Any) -> bool: ...
    def add(self, item: Any) -> None: ...
    def remove(self, item: Any) -> None: ...
    def pop(self) -> Any: ...
    def intersection(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> _ComplementSet: ...
    def __and__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> _ComplementSet: ...
    __rand__ = __and__
    def __iand__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> Self: ...
    def union(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> _ComplementSet: ...
    def __or__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> _ComplementSet: ...
    __ror__ = __or__
    def __ior__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> Self: ...
    def update(self, items: Iterable[Any]) -> None: ...
    def discard(self, items: Iterable[Any]) -> None: ...
    def symmetric_difference(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> _ComplementSet: ...
    def __xor__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> _ComplementSet: ...
    __rxor__ = __xor__
    def symmetric_difference_update(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> None: ...
    def isdisjoint(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> bool: ...
    def issubset(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> bool: ...
    def __le__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> bool: ...
    def __lt__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> bool: ...
    def issuperset(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> bool: ...
    def __ge__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> bool: ...
    def __gt__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> bool: ...
    def difference(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> _ComplementSet: ...
    def __sub__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> _ComplementSet: ...
    def __rsub__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> _ComplementSet: ...
    def difference_update(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> None: ...
    def __isub__(self, other: set[Any] | frozenset[Any] | _ComplementSet) -> Self: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __bool__(self) -> bool: ...
